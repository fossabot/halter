# export_network_config.py
"""
Модуль для генерации конфигурационных файлов
"""

import ipaddress
from collections.abc import Callable
from pathlib import Path
from typing import Protocol

from rich import print

from halter.core.models.device import Device
from halter.core.models.interface import NetworkInterface, VlanMode
from halter.core.models.network import Network
from halter.core.models.project import Project


# === Тип для обработчиков ===
class ConfigExporter(Protocol):
    def __call__(
        self, device: Device, network_map: dict[str, Network]
    ) -> dict[str, str]: ...


# === Регистр обработчиков ===
EXPORT_HANDLERS: dict[str, ConfigExporter] = {}


def register_handler(
    software_id: str,
) -> Callable[[ConfigExporter], ConfigExporter]:
    def decorator(fn: ConfigExporter) -> ConfigExporter:
        EXPORT_HANDLERS[software_id] = fn
        return fn

    return decorator


def export_networking_configs(
    project: Project,
    output_dir: Path,
) -> None:
    # Создаём путь: отдельная папка для проекта
    project_dir = output_dir / project.name
    project_dir.mkdir(parents=True, exist_ok=True)

    for device in project.devices:
        # Поддиректория для устройства
        device_dir = project_dir / device.name
        device_dir.mkdir(parents=True, exist_ok=True)

        # Экспорт конфигурации
        configs = export_interface_configs_of_device(device, project.networks)

        # Сохраняем в файл: <device_dir>/interfaces
        save_configs(device_dir, configs)


def save_configs(output_dir: Path, configs: dict[str, str]) -> None:
    output_dir.mkdir(parents=True, exist_ok=True)
    for filename, content in configs.items():
        (output_dir / filename).write_text(content, encoding="utf-8")
        print(f"[green]Interface config saved to {output_dir}[/green]")


# === Главная функция ===
def export_interface_configs_of_device(
    device: Device, networks: list[Network]
) -> dict[str, str]:
    """
    Главная функция: собирает конфиги по всем интерфейсам устройства,
    используя зарегистрированные обработчики.
    """
    results: dict[str, str] = {}
    network_map = {net.name: net for net in networks}

    # Группируем интерфейсы по software_id
    grouped: dict[str, list[NetworkInterface]] = {}
    for iface in device.interfaces:
        grouped.setdefault(iface.software_id, []).append(iface)

    # Обрабатываем каждый тип
    for software_id, interfaces in grouped.items():
        if handler := EXPORT_HANDLERS.get(software_id):
            # Создаём временное устройство с нужными интерфейсами
            temp_device = Device(
                name=device.name,
                description=device.description,
                model=device.model,
                role=device.role,
                interfaces=interfaces,
            )
            results.update(handler(temp_device, network_map))
        else:
            raise ValueError(
                f"No handler registered for software_id='{software_id}'"
            )

    return results


@register_handler("networking")
def export_linux_networking(
    device: Device, network_map: dict[str, Network]
) -> dict[str, str]:
    lines: list[str] = []
    has_header = False

    for iface in device.interfaces:
        if not has_header:
            lines.extend(
                [
                    "# /etc/network/interfaces - generated by Halter",
                    "source /etc/network/interfaces.d/*",
                    "# The loopback network interface",
                    "auto lo",
                    "iface lo inet loopback",
                    "",
                ]
            )
            has_header = True

        if not (net := network_map.get(iface.network_id)):
            raise ValueError(f"No network found for interface '{iface.name}'")

        lines.extend(
            [
                f"auto {iface.name}",
                f"iface {iface.name} inet static",
                f"    address {iface.address}",
                f"    netmask {ipaddress.ip_network(net.address, strict=False).netmask}",
            ]
        )

        if iface.vlan_mode != VlanMode.ACCESS and net.vlan:
            lines.extend(
                [
                    f"    vlan-raw-device {iface.name}",
                    f"    vlan-id {net.vlan.id}",
                ]
            )

        for route_name in iface.routes:
            if not (route_net := network_map.get(route_name)):
                raise ValueError(f"Invalid route: {route_name}")
            lines.extend(
                [
                    f"    up ip route add {route_net.address} via {net.gateway} dev {iface.name}",
                ]
            )
        lines.append("")

    return {"interfaces": "\n".join(lines)}


@register_handler("regul_networking")
def export_regul_networking(
    device: Device, network_map: dict[str, Network]
) -> dict[str, str]:
    ip_lines: list[str] = []
    route_lines: list[str] = []

    for iface in device.interfaces:
        if not (net := network_map.get(iface.network_id)):
            raise ValueError(f"No network found for interface '{iface.name}'")

        cidr = ipaddress.ip_network(net.address, strict=False)
        ip_lines.append(f"{iface.name}={iface.address} {cidr.netmask}")

        for route_name in iface.routes:
            if not (route_net := network_map.get(route_name)):
                raise ValueError(f"Invalid route: {route_name}")
            route_lines.append(f"-net {route_net.address} {net.gateway}")

    config_lines = (
        ["[global]", f"hostname={device.name}", "", "[ip]"]
        + ip_lines
        + ["", "[routing]", "gateway="]
    )

    return {
        "network.cfg": "\n".join(config_lines),
        "routes": "\n".join(route_lines),
    }


@register_handler("moxa_networking")
def export_moxa_networking(
    device: Device, network_map: dict[str, Network]
) -> dict[str, str]:
    lines: list[str] = []
    return {"config": "\n".join(lines)}
